#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ; Interrupts setup
        ORG     0xFFE8                  ; Set vector for timer interrupt 
        DC16    ISR_TIMER               ; subroutine
        
        ORG     0xFFDA                  ; Set vector for S1/S2 interrupt
        DC16    ISR_PORT1               ; subroutine
        
        ; Rest of program setup
        ORG     0xFFFE                  ; vector for RESET
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment
        ORG     0x1C00                  ; RAM starting location

; ======== Variable/array directives ========
; Each character on the screen is drawn via the indices present in the 
; following arrays. 
; ==== Letters A-Z ====
;           A     B     C     D     E     F     G     H     I     J     K     L     M     N     O     P     Q     R     S     T     U     V     W     X     Y     Z  
CHAR_H db 0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8E, 0xBD, 0x6F, 0x90, 0x78, 0x0E, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90
CHAR_L db 0x00, 0x50, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x22, 0x00, 0xB0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0x28, 0x0A, 0xAA, 0xB0, 0x28   
; Indices: 0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25    

; ==== Numbers 0-9. Memory from previous array. ====
;           0     1     2     3     4     5     6     7     8     9    EMPTY
DIGIT_H db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7, 0x00
DIGIT_L db 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00
; Indices:  26    27    28    29    30    31    32    33    34    35    36

; ==== 
; LCD characters (in memory) are offset by values. Fills characters on 
; the LCD from left to right by adding to 0x0A20. This results in the 
; memory address for the high byte. Offset by one to calculate the address 
; of the low byte.
; ====
LCD_OFFSETS db 9, 5, 3, 18, 14, 7

; ==== Program Screen Arrays ====
; Must be of length 6
;        K   A  S   I   N  O  
TITLE  db 10, 0, 18, 8, 13, 14
;         R   E  C  O   R   D
RECORD db 17, 4, 2, 14, 17, 3
;         T   E  S   T
TEST   db 19, 4, 18, 19, 36, 36
;         P   L   A  Y   E  R
PLAYER db 15, 11, 0, 24, 4, 17
;                 X   X   X   X   X   X
NO_HIGH_SCORE db 23, 23, 23, 23, 23, 23
;         F  R   A  M 
FRAM   db 5, 17, 0, 12, 36, 36
;         L   U   I  S
LUIS   db 11, 20, 8, 18, 36, 36
;         A  N   T   H  O   N
ANTHON db 0, 13, 19, 7, 14, 13
;         Y   A  R   I  E  L
YARIEL db 24, 0, 17, 8, 4, 11
;         N   I  C  O   L   E
NICOLE db 13, 8, 2, 14, 11, 4
;         D  R   A  C  I  R
DRACIR db 3, 17, 0, 2, 8, 17
;         U   I  M   E  R   F
UIMERF db 20, 8, 12, 4, 17, 5
;         O   R   A  V   A  N
ORAVAN db 14, 17, 0, 21, 0, 13
; List of names for player selection screen
NAMES  dw LUIS, ANTHON, YARIEL, NICOLE, DRACIR, UIMERF, ORAVAN
; ==== Notes on the registers ====
; These denote the registers which should store "permanent values" for the 
; current program loop. This is done to differentiate from registers used for
; indices, checks, or iterations.  
;
; ==== Registers ==== 
; R4: Stores the current screen page for *any* pages with screens
; R10: Stores what state to render. Each state is defined by a constant.
; R12: Stores the selected name by the player.
; R13: Keeps track of the desired elapsed time (in seconds).
; R14: Increases each time the timer interrupt is called. 
; R15: Stores the starting address of the array containing the indices 
;      needed to draw a character.

; ==== States ====
; (Each state is stored in R10)
; 0: Title Screen
; 1: Records
; 2: "Player" Screen
; 3: Player Selection
; 4: Test/Pro Selection Screen
; 5: Pro Mode
; 6: Test Mode
; 7: Results

; ==== FRAM Memory ====
; FRAM Array: 0x4400-0x4405
; High Scorer Name: 0x4406-0x440B
; High Score: 0x440C
; Test High Score: 0x440D

init:   MOV     #SFE(CSTACK), SP        ; set up stack

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activate
                                        ; previously configured port settings

; ===== Ports/LCD/Timer/Interrupts setup. =====
; ===== 
; Objective: Initialize the MSP430 ports, timers, interrupts, 
;            and energize the display. 
; =====
; ===== 
; Postconditions: Will reset and activate the necessary input pins. Also
;                 activates the necessary settings for the LCD, interrupts, 
;                 and the timers to function. 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/14/22-11/16/22 =====
SUB_setupDeviceHardware:     
        ; Manage Ports
        bis.b #11111001B, &P1DIR   ; set P1.1/2 to input 
        mov.b #00000110B, &P1REN   ; activate P1.1/2 pull-up/down resistors
        bis.b #00000110B, &P1OUT   ; set P1.1/2 to pull up resistor
        bic.b #BIT0, &P1OUT        ; set P1.0 LED off 

        ; Enable LCD segments: 0-21, 26-43
        mov #0xFFFF, &LCDCPCTL0
        mov #0xFC3F, &LCDCPCTL1
        mov #0x0FFF, &LCDCPCTL2
          
        ; Initialize LCD 
        mov #0x041e, &LCDCCTL0 ; sets display with hardware specs needed
        mov #0x0208, &LCDCVCTL ; enable voltage for display
        mov #0x8000, &LCDCCPCTL ; enable clock synchronization
        mov #2, &LCDCMEMCTL ; clear LCD memory (resets screen)
        bis #1, &LCDCCTL0 ; turn the LCD on

        ; Configure timer
        ; Period = cycles * (divider/SMCLK) 
        ; SMCLK = 1 MHz
        mov #CCIE, &TA0CCTL0 ; Enable TACCR0 interrupt. CCIE: Constant
        mov #TASSEL_2+MC_1+ID_3, &TA0CTL ; SMCLK (1 MHz) & Up Mode selected
        NOP                              ; divider = 8       
        mov #15625, &TA0CCR0 ; Set the timer capture to 1/8 of a second 
                             ; (from formula)

        ; Configure Interrupts
        bis.b #00000110B, &P1IE  ; Enable interrupt at P1.1/2
        bis.b #00000110B, &P1IES ; Set high-low transition on P1.1/2
        bic.b #00000110b, &P1IFG ; To erase a flag (on P1.1/2) 
                                 ; raised before activating the GIE. 
                                 ; This helps to avoid responding to a 
                                 ; button push prior to program start.

; Program is handled by interrupts
main:   MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        ; Initialize program (not a mainloop)
        call #SUB_initializeValues
        ; Activate GIE & enter Low Power Mode 0
        NOP                             ; NOP before setting GIE required 
        bis  #GIE+LPM0, SR              ; Enables GIE + LPM0     
        NOP                             ; Wait after setting interrupt

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
    
; ===== Initialization subroutines =====
; ===== 
; Objective: Initialize the various registers and settings utilized by the game.
; =====
; ===== 
; Preconditions: Must only be called the first time the program runs on an MSP 
;                or when the MSP is turned on. 
; =====
; ===== 
; Postconditions: Modifies any registers or locations in memory that store
;                 data that persists during the program.  
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/17/22 =====
SUB_initializeValues:
        mov #0, R4 ; controls screens or page indices
        mov #0, R10 ; Start on the title screen
        mov #0, R13 ; Don't need to keep track of time initially 
        mov #0, R14 ; 0 timer counts 
        call #SUB_FRAMSetup   ; Setup FRAM 
        call #SUB_titleScreen ; Display the title screen
        ret 

; ===== FRAM initializer subroutines =====
; ===== 
; Objective: Verify if FRAM contains high score data, else, initialize it.
; =====
; ===== 
; Postconditions: Modifies FRAM, if it hasn't been initialized it,  
;                 by initializing it with an empty player  (XXXXXX) 
;                 and a score of 0. Else, leaves its contents untouched. 
;                 Stores values in contiguous places in memory.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/17/22-11/18/22 =====
SUB_FRAMSetup:
        push.w R5
        mov &0x4400, R5 ; first location in memory for FRAM
        ; Check whether FRAM has been correctly initialized based on 
        ; requirements. FRAM has been correctly set up if the first 6
        ; places in memory contain the FRAM array of characters.
        push.w R6 ; index for FRAM array
        mov #0, R6
        jmp validateFRAM

validateFRAM:
        cmp #6, R6 ; end of FRAM array. FRAM has been previously initialized
                   ; correctly. Don't overwrite its contents.
        jeq endFRAMSetup
        cmp.b @R5, FRAM(R6) ; Compare memory in FRAM to FRAM array contents.
                            ; They should line up. 
        jne initializeFRAM
        inc R5 ; go to next value in FRAM array memory
        inc R6 ; increase FRAM array index
        jmp validateFRAM 
        
initializeFRAM: ; set XXXXXX for top scorer and 0 for their score
        ; This certifies that our code has correctly accessed the FRAM locations.
        mov #FRAM, &0x4400 
        ; Store a dummy higher scorer
        mov #NO_HIGH_SCORE, &0x4406
        ; Store 0 as highest score so far 
        mov.b #0, &0x440C
        ; Test score
        mov.b #0, &0x440D
        jmp endFRAMSetup

endFRAMSetup:
        pop R6
        pop R5
        ret

; ===== Game State Managers =====

; ===== Button Game State Manager Subroutine =====
; ===== Objective: Controls *button* sensitive game states. =====
; ===== Preconditions: Must be called from the PORT1 ISR. =====
; ===== 
; Postconditions: Executes the corresponding state based on the value of R10.
; =====
; ===== Author: Yariel Mercado, Nicole Roman =====
; ===== Date: 11/17/22 =====
SUB_buttonStateManager: 
        cmp #0, R10
        jeq SUB_titleScreen
        cmp #1, R10
        jeq SUB_recordScreen
        cmp #2, R10
        jeq SUB_playerScreen
        cmp #3, R10
        jeq SUB_playerSelectionScreen
        ret
       
; ===== Timer State Manager Subroutine =====
; ===== Objective: Controls *time* sensitive game states or actions. =====
; ===== Preconditions: Must be called from the TIMER ISR. =====
; ===== 
; Postconditions: Executes the corresponding state based on the current state
;                 (R10). 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/18/22 =====
SUB_timerStateManager:
        cmp #1, R10 ; currently in the record screen
        jeq SUB_updateRecordScreen
        ret
        
; ===== Button Press Subroutines =====
; ===== 
; Objective: Executes the necessary commands based on what buttons the user 
;            pressed. 
; =====
; ===== 
; Preconditions: Must be called from either of the ISRs after a *succesful*
;                button press.
; =====
; ===== 
; Postconditions: Jumps to the corresponding state transition based on the
;                 current game state.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/17/22 =====
SUB_S1ButtonHandler:
        ; on the title screen, transitions to Record
        cmp #0, R10 
        jeq SUB_recordStateTransition 
        ; on the "Player" screen, transitions to Player Select
        cmp #2, R10 
        jeq SUB_playerSelectionStateTransition 
        ; Cycle through the names on the player select screen
        cmp #3, R10 
        jeq SUB_updatePlayerScreen
        ret
        
SUB_S2ButtonHandler:
        ; Quits the record screen
        cmp #1, R10 
        jeq SUB_playerScreenStateTransition
        ; Quits the player selection screen
        cmp #3, R10 
        jeq SUB_modeSelectionTransition
        ret
        
 ; ===== Transition Subroutines =====
; ===== 
; Objective: Transitions to a different state based on both button presses as
;            well as the current state.
; =====
; ===== Preconditions: Must be called from either of the ISRs. =====
; ===== 
; Postconditions: Increments the register to the next transition. State 
;                 transitions are handled by the state managers.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/18/22 =====
SUB_recordStateTransition:      
        inc R10             ; R10 == 1 (the Record Scores display)
        mov #16, R13        ; Set transitions to every 2 seconds
        call #SUB_enableTimer ; Enable timer
        mov #2, &LCDCMEMCTL ; clear screen before going to next state
        ret
        
SUB_playerScreenStateTransition:
        inc R10                ; R10 == 2 (the "Player" screen)
        call #SUB_disableTimer ; Not needed for player select
        mov #2, &LCDCMEMCTL 
        ret
        
SUB_playerSelectionStateTransition:
        inc R10                ; R10 == 3 (the Player Select screen)
        mov #0, R4             ; Keep track of the pages in the player select
                               ; screen
        mov #2, &LCDCMEMCTL 
        ret

SUB_modeSelectionTransition:
        push.w R4
        add R4, R4             ; Note: NAMES is an array of words
        mov NAMES(R4), R12     ; Store the selected name in R12
        pop R4
        ; R10 == 4 (the Test/Pro selection screen)
        inc R10                
        mov #2, &LCDCMEMCTL 
        ret
 
; ===== States Execution =====

; ===== Title screen display subroutine =====
; ===== 
; Objective: Displays the title screen and remains here until the user presses
;            S1.
; =====
; ===== 
; Preconditions: An array of length 6 with the indices of the characters to be 
;                drawn must be properly defined. 
; =====
; ===== Postconditions: Draws the title screen onto the LCD. =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/14/22-11/17/22 =====
SUB_titleScreen:
        call #SUB_disableTimer ; not needed for the timer screen
        mov #TITLE, R15
        call #SUB_displayCharacterArray
        ret
        
; ===== Record screen subroutines =====
; ===== 
; Objective: Loops around the various Record screens based on R4's value.
; =====
; ===== 
; Preconditions: The screen must be cleared.
; =====
; ===== 
; Postconditions: Draws the various record screens onto the LCD. R4 is 
;                 incremented every 2 seconds by the timer. 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/17/22-11/18/22 =====
SUB_recordScreen:
        ; RECORD
        cmp #0, R4
        jeq drawRecord
        ; Record Holder
        cmp #1, R4
        jeq drawTopScorer
        ; Record Score
        cmp #2, R4
        jeq drawTopProScore
        ; TEST
        cmp #3, R4
        jeq drawTest
        ; Test Score
        cmp #4, R4
        jeq drawTestScore
        jmp endRecordScreen
        
drawRecord:
        mov #RECORD, R15
        call #SUB_displayCharacterArray
        jmp endRecordScreen

drawTopScorer:
        mov &0x4406, R15 ; Top scorer is stored here in FRAM
        call #SUB_displayCharacterArray
        jmp endRecordScreen
        
drawTopProScore:
        mov.b &0x440C, R15 ; Top PRO mode score is stored here in FRAM
        jmp drawScore

drawTest:
        mov #TEST, R15
        call #SUB_displayCharacterArray
        jmp endRecordScreen
        
drawTestScore:
        mov.b &0x440D, R15 ; Top TEST mode score is stored here in FRAM
        jmp drawScore

drawScore:
      ; Draw onto memory the value of that num
      mov.b DIGIT_H(R15), &0xA27  ; R15 is in the range of [0, 6]
      mov.b DIGIT_L(R15), &0xA28
      jmp endRecordScreen

endRecordScreen:
        ret

; ===== Update record screen subroutine =====
; ===== 
; Objective: Updates the Record screen display based on the timer and the 
;            current "page". 
; =====
; ===== 
; Preconditions: R4 must be between 0-4.  
; =====
; ===== 
; Postconditions: Updates the current record screen onto the LCD. 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/18/22 =====
SUB_updateRecordScreen:
        cmp #4, R4 ; loop back to the starting screen
        jeq resetR4Index
        inc R4
        jmp updateScreen

resetR4Index:
        clr R4
        jmp updateScreen

updateScreen:
        mov #2, &LCDCMEMCTL ; clear screen before drawing a new record screen
        call #SUB_recordScreen  
        ret
     
; ===== Player Selection Screen Subroutines =====
; ===== 
; Objective: Loops around the names of possible players based on the value of R4. 
; =====
; =====  Preconditions: R4 must be within the range of 0-8. =====
; ===== 
; Postconditions: Draws the various player names onto the LCD and saves the 
;                 selected option in R12.
; =====
; ===== Author: Nicole Roman, Yariel Mercado =====
; ===== Date: 11/19/22-11/21/22 =====
SUB_playerScreen:
        mov  #PLAYER, R15
        call #SUB_displayCharacterArray
        ret

SUB_playerSelectionScreen:
        push.w R4
        add R4, R4 ; dealing with an array of words, double R4
        mov NAMES(R4), R15 ; display the player name at the correct index
        pop R4
        call    #SUB_displayCharacterArray
        ret

; ===== Player Selection Screen Page Iterator =====
; ===== 
; Objective: Manage the value of R4 to draw the appropriate player name.  
; =====
; =====  Preconditions: The screen must be cleared. =====
; ===== 
; Postconditions: Sets R4 to the correct value on the player selection screen.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/19/22-11/21/22 =====
SUB_updatePlayerScreen:
        cmp     #6, R4
        jeq     resetPlayerIterator
        inc     R4
        jmp     updateSelection

resetPlayerIterator:
        clr     R4
        jmp     updateSelection
        
updateSelection:
        mov #2, &LCDCMEMCTL ; Screen is later updated after the ISR processes
                            ; the button presses.
        
        ret
        
; ===== General subroutines. =====

; ===== General LCD display subroutines. =====
; ===== 
; Objective: Given an array of numbers, displays the characters at those 
;            positions on the LCD. 
; =====
; ===== 
; Preconditions: R15 must be an array of size 6 containing only numerical values, 
;                in order to access the values at that index and write it
;                to the LCD's memory. Screen should also be cleared beforehand.
;                Each integer, representing the character to be drawn, should
;                go from 0-36.
; =====
; ===== 
; Postconditions: Draws the indicated numbers or letters onto the LCD.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/14/22-11/17/22 =====
SUB_displayCharacterArray: ; sets up registers to be utilized by the subroutines
        push.w R5 ; Lookup index for the character arrays
        push.w R6 ; Iteration index for LCD memory offsets/6 array elements
        push.w R7 ; Value for current LCD memory offset (same index as R6)
        ; initialize values
        mov #0, R6
        jmp displayCharacterData

displayCharacterData:
        ; Perform this check first (edge case: Empty char in last index of arr)
        cmp #6, R6 ; end of the array 
        jeq endDrawing
        ; Proceed with drawing all other characters
        mov.b @R15, R5 ; Store value of the index for the current letter to draw
        mov.b LCD_OFFSETS(R6), R7 ; where in LCD memory to draw (offset)
        ; increment first to safely skip writing to the screen when EMPTY
        inc R6
        inc R15 ; increase to next location in array
        ; don't move 0x00 (EMPTY) into memory to prevent overwrites
        cmp #36, R5 
        jeq displayCharacterData 
        ; draw characters
        mov.b CHAR_H(R5), 0x0A20(R7)
        mov.b CHAR_L(R5), 0x0A20+1(R7)
        jmp displayCharacterData

endDrawing:  ; restore non-permanent modification registers (check comments)
        pop R7
        pop R6
        pop R5
        ret  

; ===== Timer management subroutines =====
; ===== 
; Objective: Control the timer ISR per the program's needs.
; =====
; ===== 
; Postconditions: Enables, disables, or resets the current timer.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/18/22 =====
SUB_disableTimer: ; Disabling a timer prevents registers from incrementing
                  ; infinitely and potentially overflowing. 
        clr R13   ; Clear current cycle count and desired cycle count
        clr R14
        bic #CCIE, &TA0CCTL0 ; Disable the timer
        ret
        
SUB_enableTimer: 
        bis #CCIE, &TA0CCTL0 ; Enable the timer. R13/R14 will have been cleared
                             ; from before. This is always called after 
                             ; disabling the timer.
        ret

; ===== Delay subroutines. =====
; ===== Objective: Decrements from a large value to stall for time. =====
; ===== Preconditions: Must be called after an interrupt or button press. =====
; ===== Posconditions: Stalls the program for a bit while inputs are processed.=====
; ======== Author: Yariel Mercado ========
; ======== Date: 11/21/22 ========
delay:
        push.w R10 ; store original value
        mov #0xFFFF, R10  
        jmp loop
        
loop:
        dec R10
        jnz loop
        pop R10 
        ret ; returns to whatever subroutine the delay was called from

; ===== Interupt subroutines. =====

; ===== Timer Interrupt Subroutine =====
; ===== 
; Objective: Control the program's time sensitive events.
; =====
; ===== 
; Preconditions: Can only handle time dependent states or transitions. The timer
;                interrupt is called every 1/8 of a second. This allows us to
;                control more specific units of time.  
; =====
; ===== 
; Postconditions: Switches to a different state or executes a program action
;                 based on the current time elapsed. 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/18/22 =====
ISR_TIMER:
        inc R14 ; keeps track of the timer's ticks
        cmp R13, R14  ; is the current number of cycles == desired #cycles
        jne TIMER_ISR_END ; not equal. End and continue to increase time
        ; Desired number of seconds have elapsed
        call #SUB_timerStateManager
        clr R14 ; reset the count
        jmp TIMER_ISR_END

TIMER_ISR_END:
        reti
        
; ===== Button Interrupt Subroutines. =====
; ===== 
; Objective: Attend user presses on S1/2 appropriately via interrupts.
; =====
; ===== 
; Preconditions: Cannot handle time sensitive events, only those triggered by
;                button presses. 
; =====
; ===== 
; Postconditions: Switches to a different state or executes a program action
;                 based on the current state.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/15/22-11/17/22 =====
ISR_PORT1:      
        ; Check S1
        bit.b   #00000010B, &P1IFG ; Test P1IFG to detect interrupt from S1    
        jnz     S1Success          ; 0 == interrupt not pending
        ; Check S2
        bit.b   #00000100B, &P1IFG
        jnz     S2Success
        ; Didn't recieve S1/2 interrupts
        bic.b #00000110B, &P1IFG      ; Clear interrupt flags
        jmp     PORT1_ISR_END  
        
S1Success: ; S1 or S2 have been succesfully pressed
        call #delay                   ; Helps process input
        bic.b #00000110B, &P1IFG      ; Clear interrupt flags
        call #SUB_S1ButtonHandler
        jmp PORT1_ISR_END
        
S2Success:
        call #delay                   ; Helps process input
        bic.b #00000110B, &P1IFG      ; Clear interrupt flags
        call #SUB_S2ButtonHandler
        jmp PORT1_ISR_END

PORT1_ISR_END:
        call #SUB_buttonStateManager  ; Manage program state
        reti
        END
        