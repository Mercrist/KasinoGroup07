#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ; Interrupts setup
        ORG     0xFFE8                  ; Set vector for timer interrupt 
        DC16    ISR_TIMER               ; subroutine
        
        ORG     0xFFDA                  ; Set vector for S1/S2 interrupt
        DC16    ISR_PORT1               ; subroutine
        
        ; Rest of program setup
        ORG     0xFFFE                  ; vector for RESET
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment
        ORG     0x1C00                  ; RAM starting location

; ======== Variable/array directives ========
; Each character on the screen is drawn via the indices present in the 
; following arrays. Define the high bytes then the low bytes in order to access
; either array with just CHAR_H. 
; ==== Letters A-Z & Numbers 0-9 ====
; Chars:    A     B     C     D     E     F     G     H     I     J     K     L     M     N     O     P     Q     R     S     T     U     V     W     X     Y     Z  
CHAR_H  db 0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8E, 0xBD, 0x6F, 0x90, 0x78, 0x0E, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90
DIGIT_H db 0xFC, 0x60, 0xDB, 0xF3, 0x67, 0xB7, 0xBF, 0x80, 0xFF, 0xF7, 0x00
; Nums:     0     1     2     3     4     5     6     7     8     9    EMPTY

; Indices:  0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25    
CHAR_L  db 0x00, 0x50, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x22, 0x00, 0xB0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0x28, 0x0A, 0xAA, 0xB0, 0x28   
DIGIT_L db 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00
;           26    27    28    29    30    31    32    33    34    35    36

; ==== 
; LCD characters (in memory) are offset by values. Fills characters on 
; the LCD from left to right by adding to 0x0A20. This results in the 
; memory address for the high byte. Offset by one to calculate the address 
; of the low byte.
; ====
LCD_OFFSETS db 9, 5, 3, 18, 14, 7

; ==== Program Screen Arrays ====
; Must be of length 6
;          K   A  S   I   N  O  
TITLE   db 10, 0, 18, 8, 13, 14
;          R   E  C  O   R   D
RECORD  db 17, 4, 2, 14, 17, 3
;          T   E  S   T
TEST    db 19, 4, 18, 19, 36, 36
;          M   O   D  E      T
MODE_T  db 12, 14, 3, 4, 36, 19
;          M   O   D  E      P
MODE_P  db 12, 14, 3, 4, 36, 15
;          P   L   A  Y   E  R
PLAYER  db 15, 11, 0, 24, 4, 17
;          X   X   X   X   X   X
NO_NAME db 23, 23, 23, 23, 23, 23
;          F  R   A  M 
FRAM    db 5, 17, 0, 12, 36, 36
;          L   U   I  S
LUIS    db 11, 20, 8, 18, 36, 36
;          A  N   T   H  O   N
ANTHON  db 0, 13, 19, 7, 14, 13
;          Y   A  R   I  E  L
YARIEL  db 24, 0, 17, 8, 4, 11
;          N   I  C  O   L   E
NICOLE  db 13, 8, 2, 14, 11, 4
;          D  R   A  C  I  R
DRACIR  db 3, 17, 0, 2, 8, 17
;          U   I  M   E  R   F
UIMERF  db 20, 8, 12, 4, 17, 5
;          O   R   A  V   A  N
ORAVAN  db 14, 17, 0, 21, 0, 13
;          P   E  R   D  I  O
PERDIO  db 15, 4, 17, 3, 8, 14
;          G  A  N   O
GANO    db 6, 0, 13, 14, 36, 36
;          S   2   C  L   R
S2CLR   db 18, 28, 2, 11, 17, 36
; List of names for player selection screen
NAMES   dw LUIS, ANTHON, YARIEL, NICOLE, DRACIR, UIMERF, ORAVAN
; List of modes for mode selection screen
MODES   dw MODE_T, MODE_P
; List of speeds for each segment in PRO mode (divide by 8 to get time in secs)
SPEED   db 16, 16, 8, 4, 2, 1

; ==== Notes on the registers ====
; These denote the registers which should store "permanent values" for the 
; current program loop. This is done to differentiate from registers used for
; indices, checks, or iterations.  
;
; ==== Registers ==== 
; R4 : Stores the current screen page (or segment) for *any* pages with screens
; R8 : Index for digit list. Also the current number displayed on modes
; R9 : Stores digit 1 for the modes (for the comparisons)
; R10: Stores what state to render. Each state is defined by a constant.
; R11: Stores the score for the modes (counter)
; R12: Stores the selected name by the player.
; R13: Keeps track of the desired elapsed time (in seconds).
; R14: Increases each time the timer interrupt is called. 
; R15: Stores the starting address of the array containing the indices 
;      needed to draw a character.

; ==== States ====
; (Each state is stored in R10)
; 0: Title Screen
; 1: Records
; 2: "Player" Screen
; 3: Player Selection
; 4: Test/Pro Selection Screen
; 5: Test Mode
; 6: Pro Mode
; 7: "PERDIO" screen
; 8: "GANO" screen
; 9: "S2CLR" screen

; ==== FRAM Memory ====
; FRAM Array: 0x4400-0x4405
; High Scorer Name: 0x4406-0x440B
; High Score: 0x440C
; Test High Score: 0x440D

init:   MOV     #SFE(CSTACK), SP        ; set up stack

UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activate
                                        ; previously configured port settings

; ===== Ports/LCD/Timer/Interrupts setup. =====
; ===== 
; Objective: Initialize the MSP430 ports, timers, interrupts, 
;            and energize the display. 
; =====
; ===== 
; Postconditions: Will reset and activate the necessary input pins. Also
;                 activates the necessary settings for the LCD, interrupts, 
;                 and the timers to function. 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/14/22-11/16/22 =====
SUB_setupDeviceHardware:     
        ; Manage Ports
        bis.b #11111001B, &P1DIR   ; set P1.1/2 to input 
        mov.b #00000110B, &P1REN   ; activate P1.1/2 pull-up/down resistors
        bis.b #00000110B, &P1OUT   ; set P1.1/2 to pull up resistor
        bic.b #BIT0, &P1OUT        ; set P1.0 LED off 

        ; Enable LCD segments: 0-21, 26-43
        mov #0xFFFF, &LCDCPCTL0
        mov #0xFC3F, &LCDCPCTL1
        mov #0x0FFF, &LCDCPCTL2
          
        ; Initialize LCD 
        mov #0x041e, &LCDCCTL0 ; sets display with hardware specs needed
        mov #0x0208, &LCDCVCTL ; enable voltage for display
        mov #0x8000, &LCDCCPCTL ; enable clock synchronization
        mov #2, &LCDCMEMCTL ; clear LCD memory (resets screen)
        bis #1, &LCDCCTL0 ; turn the LCD on

        ; Configure timer
        ; Period = cycles * (divider/SMCLK) 
        ; SMCLK = 1 MHz
        mov #CCIE, &TA0CCTL0 ; Enable TACCR0 interrupt. CCIE: Constant
        mov #TASSEL_2+MC_1+ID_3, &TA0CTL ; SMCLK (1 MHz) & Up Mode selected
        NOP                              ; divider = 8       
        mov #15625, &TA0CCR0 ; Set the timer capture to 1/8 of a second 
                             ; (from formula)

        ; Configure Interrupts
        bis.b #00000110B, &P1IE  ; Enable interrupt at P1.1/2
        bis.b #00000110B, &P1IES ; Set high-low transition on P1.1/2
        bic.b #00000110b, &P1IFG ; To erase a flag (on P1.1/2) 
                                 ; raised before activating the GIE. 
                                 ; This helps to avoid responding to a 
                                 ; button push prior to program start.

; Program is handled by interrupts
main:   MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        ; Initialize program (not a mainloop)
        call #SUB_initializeValues
        ; Activate GIE & enter Low Power Mode 0
        NOP                             ; NOP before setting GIE required 
        bis  #GIE+LPM0, SR              ; Enables GIE + LPM0     
        NOP                             ; Wait after setting interrupt

        JMP $                           ; jump to current location '$'
        NOP                             ; (endless loop)
    
; ===== Initialization subroutines =====
; ===== 
; Objective: Initialize the various registers and settings utilized by the game.
; =====
; ===== 
; Preconditions: Must only be called the first time the program runs on an MSP 
;                or when the MSP is turned on. 
; =====
; ===== 
; Postconditions: Modifies any registers or locations in memory that store
;                 data that persists during the program.  
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/17/22 =====
SUB_initializeValues:
        mov #0, R10 ; Start on the title screen
        call #SUB_disableTimer ; not needed for the title screen
        call #SUB_FRAMSetup   ; Setup FRAM 
        call #SUB_titleScreen ; Display the title screen   
        ret 

; ===== FRAM initializer subroutines =====
; ===== 
; Objective: Verify if FRAM contains high score data, else, initialize it.
; =====
; ===== 
; Postconditions: Modifies FRAM, if it hasn't been initialized it,  
;                 by initializing it with an empty player  (XXXXXX) 
;                 and a score of 0. Else, leaves its contents untouched. 
;                 Stores values in contiguous places in memory.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/17/22-11/18/22 =====
SUB_FRAMSetup:
        push.w R5
        mov &0x4400, R5 ; first location in memory for FRAM
        ; Check whether FRAM has been correctly initialized based on 
        ; requirements. FRAM has been correctly set up if the first 6
        ; places in memory contain the FRAM array of characters.
        push.w R6 ; index for FRAM array
        mov #0, R6
        jmp validateFRAM

validateFRAM:
        cmp #6, R6 ; end of FRAM array. FRAM has been previously initialized
                   ; correctly. Don't overwrite its contents.
        jeq endFRAMSetup
        cmp.b @R5, FRAM(R6) ; Compare memory in FRAM to FRAM array contents.
                            ; They should line up. 
        jne initializeFRAM
        inc R5 ; go to next value in FRAM array memory
        inc R6 ; increase FRAM array index
        jmp validateFRAM 
        
initializeFRAM: ; set XXXXXX for top scorer and 0 for their score
        ; This certifies that our code has correctly accessed the FRAM locations.
        mov #FRAM, &0x4400 
        ; Store a dummy higher scorer
        mov #NO_NAME, &0x4406
        ; Store 0 as highest score so far 
        mov.b #0, &0x440C
        ; Test score
        mov.b #0, &0x440D
        jmp endFRAMSetup

endFRAMSetup:
        pop R6
        pop R5
        ret

; ===== Game State Managers =====

; ===== Button Game State Manager Subroutine =====
; ===== Objective: Controls *button* sensitive game states. =====
; ===== Preconditions: Must be called from the PORT1 ISR. =====
; ===== 
; Postconditions: Executes the corresponding state based on the value of R10.
; =====
; ===== Author: Yariel Mercado, Nicole Roman, Anthony Mendez =====
; ===== Date: 11/17/22 - 11/25/22 =====
SUB_buttonStateManager: 
        cmp #0, R10
        jeq SUB_titleScreen
        cmp #1, R10
        jeq SUB_recordScreen
        cmp #2, R10
        jeq SUB_playerScreen
        cmp #3, R10
        jeq SUB_playerSelectionScreen
        cmp #4, R10
        jeq SUB_modeSelectionScreen
        cmp #5, R10
        jeq SUB_testModeScreen
        cmp #6, R10
        jeq SUB_proModeScreen
        cmp #7, R10
        jeq SUB_perdioScreen 
        cmp #8, R10
        jeq SUB_ganoScreen
        cmp #9, R10
        jeq SUB_S2CLRscreen       
        ret
       
; ===== Timer State Manager Subroutine =====
; ===== Objective: Controls *time* sensitive game states or actions. =====
; ===== Preconditions: Must be called from the TIMER ISR. =====
; ===== 
; Postconditions: Executes the corresponding state based on the current state
;                 (R10). 
; =====
; ===== Author: Yariel Mercado, Anthony Mendez =====
; ===== Date: 11/18/22 - 11/25/22 =====
SUB_timerStateManager:
        cmp #1, R10 ; currently in the record screen
        jeq SUB_updateRecordScreen
        cmp #5, R10 ; currently in the test mode screen
        jeq SUB_updateTestDigit
        cmp #6, R10 ; currently in the pro mode screen
        jeq SUB_updateProDigit
        cmp #7, R10 ; currently in the 'PERDIO' screen
        jeq SUB_s2clrTransitionPerdio
        cmp #8, R10 ; currently in the 'GANO' screen
        jeq SUB_s2clrTransitionGano
        ret
        
; ===== Button Press Subroutines =====
; ===== 
; Objective: Executes the necessary commands based on what buttons the user 
;            pressed. 
; =====
; ===== 
; Preconditions: Must be called from either of the ISRs after a *succesful*
;                button press.
; =====
; ===== 
; Postconditions: Jumps to the corresponding state transition based on the
;                 current game state.
; =====
; ===== Author: Yariel Mercado, Anthony Mendez =====
; ===== Date: 11/17/22 - 11/25/22 =====
SUB_S1ButtonHandler:
        ; on the title screen, transitions to Record
        cmp #0, R10 
        jeq SUB_recordStateTransition 
        ; on the "Player" screen, transitions to Player Select
        cmp #2, R10 
        jeq SUB_playerSelectionStateTransition 
        ; Cycle through the names on the player select screen
        cmp #3, R10 
        jeq SUB_updatePlayerScreen
        ; Cycle through the modes on the mode selection screen
        cmp #4, R10
        jeq SUB_updateModeScreen
        ; Move to next segment and compare selection to first digit if R4 > 0
        cmp #5, R10
        jeq SUB_selectionTest
        ; Move to next segment and compare selection to first digit if R4 > 0
        cmp #6, R10
        jeq SUB_selectionPro
        ; Quits S2CLR screen and returns to title screen
        cmp #9, R10
        jeq SUB_titleScreenTransition
        ret
        
SUB_S2ButtonHandler:
        ; Quits the record screen
        cmp #1, R10 
        jeq SUB_playerScreenStateTransition
        ; Quits the player selection screen
        cmp #3, R10 
        jeq SUB_modeSelectionTransition
        ; Quits the mode selection screen
        cmp #4, R10
        jeq SUB_testOrProModeTransition
        ; sets TEST and PRO scores to zero
        cmp #9, R10
        jeq SUB_clrRecords
        ret
        
 ; ===== Transition Subroutines =====
; ===== 
; Objective: Transitions to a different state based on both button presses as
;            well as the current state.
; =====
; ===== Preconditions: Must be called from either of the ISRs. =====
; ===== 
; Postconditions: Increments the register to the next transition and sets 
;                 the register values to the next state's requirements. 
; =====
; ===== Author: Yariel Mercado, Anthony Mendez, Luis D. Gonzalez =====
; ===== Date: 11/18/22 - 11/25/22 =====
SUB_recordStateTransition:      
        mov #0, R4          ; controls screens or page indices
        inc R10             ; R10 == 1 (the Record Scores display)
        mov #16, R13        ; Set transitions to every 2 seconds
        call #SUB_enableTimer ; Enable timer
        mov #2, &LCDCMEMCTL ; clear screen before going to next state
        ret
        
SUB_playerScreenStateTransition:
        inc R10                ; R10 == 2 (the "Player" screen)
        call #SUB_disableTimer ; Not needed for player select and mode select
        mov #2, &LCDCMEMCTL 
        ret
        
SUB_playerSelectionStateTransition:
        inc R10                ; R10 == 3 (the Player Select screen)
        mov #0, R4             ; Keep track of the pages in the player select
                               ; screen
        mov #2, &LCDCMEMCTL 
        ret

SUB_modeSelectionTransition:
        add R4, R4             ; Note: NAMES is an array of words
        mov NAMES(R4), R12     ; Store the selected name in R12
                               ; R10 == 4 (the Test/Pro selection screen)
        inc R10                
        clr R4                 ; used as a paginator for PRO/TEST select
        mov #2, &LCDCMEMCTL 
        ret

SUB_testOrProModeTransition:
        inc R4                 ; increase the paginator num by 1 to match state
        add R4, R10            ; this way, adds 1 if R4 == 0, add 2 if R4 == 1.
                               ; R10 == 5 (TEST mode)
                               ; R10 == 6 (PRO  mode)
        clr R4                 ; current segment on the screen (0-5) for modes
        clr R8                 ; index starts at 0
        clr R9                 ; set segment 1 value to zero momentarily
        mov #1, R11            ; Score starts at 1 (goes from 1 to 6)
        mov #2, &LCDCMEMCTL 
        cmp #5, R10            ; if R10 == 5, go to TEST
        jeq SUB_testModeTransition 
        cmp #6, R10            ; if R10 == 6, go to PRO
        jeq SUB_proModeTransition
        ret

SUB_testModeTransition:
        mov #16, R13            ; For TEST, digits transitions every 2 seconds
        call #SUB_enableTimer  ; Enable timer for the mode
        ret

SUB_proModeTransition:
        mov #16, R13           ; For PRO, first 2 digits transition every 2 secs
        call #SUB_enableTimer  ; Enable timer for the mode
        ret

SUB_perdioTransitionTest:
        clr R8                 ; Reset the digit list index 
        clr R9                 ; Reset the first digit
        incd R10               ; From TEST: R10 = 5 + 2 -> R10 = 7
        mov #40, R13           ; Timer set to 5 seconds
        mov #2, &LCDCMEMCTL 
        call #SUB_perdioScreen ; Display screen
        call #SUB_updateTestScore
        ret

SUB_ganoTransitionTest:
                               ; No need for comparison if player wins
        mov.b R11, &0x440D     ; replaces FRAM TEST Score to value of R11
        clr R8                 ; Reset the digit list index 
        clr R9                 ; Reset the first digit
        add #3, R10            ; From TEST: R10 = 5 + 3 -> R10 == 8
        mov #40, R13           ; Timer set to 5 seconds
        mov #2, &LCDCMEMCTL 
        call #SUB_ganoScreen   ; Display screen
        ret
        
SUB_perdioTransitionPro:
        clr R8                 ; Reset the digit list index 
        clr R9                 ; Reset the first digit
        add #1, R10            ; From PRO: R10 = 6 + 1 -> R10 = 7
        mov #40, R13           ; Timer set to 5 seconds
        mov #2, &LCDCMEMCTL 
        call #SUB_perdioScreen
        call #SUB_updateProScore
        ret
        
SUB_ganoTransitionPro:
                               ; No need for comparison if player wins
        mov.b R11, &0x440C     ; Updates FRAM PRO Score to value of R11
        mov.b R12, &0x4406     ; Updates FRAM PRO Name to value of R12
        clr R8                 ; Reset the digit list index 
        clr R9                 ; Reset the first digit
        incd R10               ; From PRO: R10 = 6 + 2 -> R10 == 8
        mov #40, R13           ; Timer set to 5 seconds
        mov #2, &LCDCMEMCTL 
        call #SUB_ganoScreen
        ret
        
SUB_s2clrTransitionPerdio:
        incd R10               ; From Perdio: R10 = 7 + 2 -> R10 == 9
        call #SUB_disableTimer ; Not needed for S2CLR screen
        mov #2, &LCDCMEMCTL 
        call #SUB_S2CLRscreen
        ret
        
SUB_s2clrTransitionGano:
        inc R10                ; From gano: R10 = 8 + 1 -> R10 == 9
        call #SUB_disableTimer ; Not needed for S2CLR screen
        mov #2, &LCDCMEMCTL 
        call #SUB_S2CLRscreen
        ret

SUB_titleScreenTransition:
        clr R4                 ; Reset R4 for the record screen
        clr R11                ; Reset score
        clr R10                ; Reset R10 to go to the title screen
        mov #2, &LCDCMEMCTL 
        ret
        
; ===== States Execution =====

; ===== Title screen display subroutine =====
; ===== 
; Objective: Displays the title screen and remains here until the user presses
;            S1.
; =====
; ===== 
; Preconditions: An array of length 6 with the indices of the characters to be 
;                drawn must be properly defined. 
; =====
; ===== Postconditions: Draws the title screen onto the LCD. =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/14/22-11/17/22 =====
SUB_titleScreen:
        mov #TITLE, R15
        call #SUB_displayCharacterArray
        ret
        
; ===== Record screen subroutines =====
; ===== 
; Objective: Loops around the various Record screens based on R4's value.
; =====
; ===== 
; Preconditions: The screen must be cleared.
; =====
; ===== 
; Postconditions: Draws the various record screens onto the LCD. R4 is 
;                 incremented every 2 seconds by the timer. 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/17/22-11/18/22 =====
SUB_recordScreen:
        ; RECORD
        cmp #0, R4
        jeq drawRecord
        ; Record Holder
        cmp #1, R4
        jeq drawTopScorer
        ; Record Score
        cmp #2, R4
        jeq drawTopProScore
        ; TEST
        cmp #3, R4
        jeq drawTest
        ; Test Score
        cmp #4, R4
        jeq drawTestScore
        jmp endRecordScreen
        
drawRecord:
        mov #RECORD, R15
        call #SUB_displayCharacterArray
        jmp endRecordScreen

drawTopScorer:
        mov &0x4406, R15 ; Top scorer is stored here in FRAM
        call #SUB_displayCharacterArray
        jmp endRecordScreen
        
drawTopProScore:
        mov.b &0x440C, R15 ; Top PRO mode score is stored here in FRAM
        jmp drawScore

drawTest:
        mov #TEST, R15
        call #SUB_displayCharacterArray
        jmp endRecordScreen
        
drawTestScore:
        mov.b &0x440D, R15 ; Top TEST mode score is stored here in FRAM
        jmp drawScore

drawScore:
      ; Draw onto memory the value of that num
      mov.b DIGIT_H(R15), &0xA27  ; R15 is in the range of [0, 6]
      mov.b DIGIT_L(R15), &0xA28
      jmp endRecordScreen

endRecordScreen:
        ret

; ===== Update record screen subroutine =====
; ===== 
; Objective: Updates the Record screen display based on the timer and the 
;            current "page". 
; =====
; ===== 
; Preconditions: R4 must be between 0-4.  
; =====
; ===== 
; Postconditions: Updates the current record screen onto the LCD. 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/18/22 =====
SUB_updateRecordScreen:
        cmp #4, R4 ; loop back to the starting screen
        jeq resetR4Index
        inc R4
        jmp updateScreen

resetR4Index:
        clr R4
        jmp updateScreen

updateScreen:
        mov #2, &LCDCMEMCTL ; clear screen before drawing a new record screen
        call #SUB_recordScreen  
        ret
     
; ===== Player Selection Screen Subroutines =====
; ===== 
; Objective: Loops around the names of possible players based on the value of R4. 
; =====
; =====  Preconditions: R4 must be within the range of 0-8. =====
; ===== 
; Postconditions: Draws the various player names onto the LCD and saves the 
;                 selected option in R12.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/19/22-11/21/22 =====
SUB_playerScreen:
        mov  #PLAYER, R15
        call #SUB_displayCharacterArray
        ret

SUB_playerSelectionScreen:
        push.w R4
        add R4, R4 ; dealing with an array of words, double R4
        mov NAMES(R4), R15 ; display the player name at the correct index
        pop R4
        call #SUB_displayCharacterArray
        ret

; ===== Player Selection Screen Page Iterator =====
; ===== 
; Objective: Manage the value of R4 to draw the appropriate player name.  
; =====
; =====  Preconditions: The screen must be cleared. =====
; ===== 
; Postconditions: Sets R4 to the correct value on the player selection screen.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/21/22 =====
SUB_updatePlayerScreen:
        cmp  #6, R4
        jeq  resetPlayerIterator
        inc  R4
        jmp  updateSelection

resetPlayerIterator:
        clr  R4
        jmp  updateSelection
        
updateSelection:
        mov #2, &LCDCMEMCTL ; Screen is later updated after the ISR processes
                            ; the button presses.
        ret

; ===== Test & Pro modes Selection Screen Subroutines =====
; ===== 
; Objective: Loops around the two modes with S1.1 and confirm with S1.2. 
; =====
; =====  Preconditions: R4 must be within the range of 0-1. =====
; ===== 
; Postconditions: R4 will store (temporally) the value of the selected mode.
;                 Stores 0 (zero) if selected mode is TEST, 1 (one) if PRO.
; =====
; ===== Author: Anthony Mendez =====
; ===== Date: 11/22/22 - 11/23/22 =====
SUB_modeSelectionScreen:
        push.w R4
        inc R4
        mov MODES(R4), R15; display the mode name at the correct index
        pop R4
        call #SUB_displayCharacterArray
        ret

; ===== Test & Pro modes Selection Screen Page Iterator Subroutines =====
; ===== 
; Objective: Verify R4's value in order to draw the corresponding mode. 
; =====
; =====  Preconditions: The screen must be cleared =====
; ===== 
; Postconditions: Sets R4 to the correct value on the TEST & PRO 
;                 selection screen.
; =====
; ===== Author: Anthony Mendez =====
; ===== Date: 11/22/22 - 11/23/22 =====
SUB_updateModeScreen:
        cmp #1, R4
        jeq resetModeIterator
        inc R4
        jmp updateModeSelection

resetModeIterator:
        clr  R4
        jmp  updateModeSelection

updateModeSelection:
        mov #2, &LCDCMEMCTL ; Screen is later updated after the ISR processes
                            ; the button presses.
        ret

; ===== Test Mode Subroutines =====
; ===== 
; Objective: From left to right, iterate through numbers from zero to 9.
;            each digit appears on screen for 2 seconds, select digit with S1.
;            If digit > 9, player loses; also, if any digit from index 1 to 5
;            is not equal to digit index 0, player also loses.
;            if by the end all numbers are equal, player wins 
; =====
; =====  Preconditions: R10 must be equal to 5 (five) =====
; ===== 
; Postconditions: store the Test score in 0x440D
;                 display "PERDIO" if player loses
;                 display "GANO" if player wins
; =====
; ===== Author: Anthony Mendez =====
; ===== Date: 11/22/22 - 11/25/22 =====
SUB_testModeScreen:
        call #SUB_displaySegmentData
        clr R14 ; set timer count to zero to allow each digit to show for 2 secs
        ret
        
SUB_selectionTest:
        cmp #0, R4                 ; if just selected first digit
        jeq storeFirstDigit        ; go store it
        cmp R8, R9                 ; compare selected number with first digit
        jne SUB_perdioTransitionTest ; Not equal: go to 'PERDIO'
                                   ; if equal do the following
        inc R4                     ; inc segment index to move to next segment
        clr R8                     ; reset index for the number (starts at 0)
        inc R11                    ; increase score
        cmp #6, R11                ; if score == 6, player wins
        jeq SUB_ganoTransitionTest ; got 6 points: go to 'GANO'
        ret
        
storeFirstDigit:
        mov R8, R9                 ; save in R9 the first digit's value (R8)
        inc R4                     ; inc segment index to move to next segment
        clr R8                     ; reset index for the number (starts at 0)
        ret

; Updates the top Test Mode record
; TODO: Document
SUB_updateTestScore:
        cmp.b &0x440D, R11     ; Check for new High Score 
        jge newRecordTest      ; Jump if R11 >= previous High Score
        jmp endTestScoreUpdate
  
newRecordTest:
        mov.b R11, &0x440D      ; replaces FRAM TEST Score to value of R11
        jmp endTestScoreUpdate

endTestScoreUpdate:
        ret
  
        
; ===== Update Digit subroutines =====
; ===== 
; Objective: Updates the display based on the timer, current segment, and 
;            index digit for test mode. 
; =====
; ===== 
; Preconditions: R5 has to be less or equal to 9 (nine).  
; =====
; ===== 
; Postconditions: Updates the next digit in the corresponding segment.
; =====
; ===== Author: Anthony Mendez =====
; ===== Date: 11/22/22 - 11/25/22 =====
        
SUB_updateTestDigit:
        cmp #9, R8 ; if the index goes beyond 9, the player loses
        jeq SUB_perdioTransitionTest
        inc R8
        jmp updateTestSegment
        
updateTestSegment:
        call #SUB_testModeScreen
        ret

; ===== Pro Mode Subroutines =====
; ===== 
; Objective: From left to right, iterate through numbers from zero to 9.
;            each digit appears on screen for less seconds
;            as player selects digits with S1.
;            If digit > 9, player loses; also, if any digit from index 1 to 5
;            is not equal to digit index 0, player also loses.
;            if by the end all numbers are equal, player wins  
; =====
; =====  Preconditions: R10 must be equal to 6 (six) =====
; ===== 
; Postconditions: store the Pro score in 0x440C, and player in 0x4406
;                 display "PERDIO" if player loses
;                 display "GANO" if player wins    
; =====
; =====
; ===== Author: Luis D. Gonzalez, Anthony Mendez =====
; ===== Date: 11/25/2022 =====
SUB_proModeScreen:
        call #SUB_displaySegmentData
        mov.b SPEED(R4), R13 ; Decrease timer speed for the value in segment R4
        clr R14 ; set timer count to zero to allow each digit to show for X secs
        ret
        
SUB_selectionPro:
        cmp #0, R4                 ; if just selected first digit
        jeq storeFirstDigitPro     ; go store it
        cmp R8, R9                 ; compare selected number with first digit
        jne SUB_perdioTransitionPro ; Not equal: go to 'PERDIO'
                                   ; if equal do the following
        inc R4                     ; inc segment index to move to next segment
        clr R8                     ; reset index for the number (starts at 0)
        inc R11                    ; increase score
        cmp #6, R11                ; if score == 6, player wins
        jeq SUB_ganoTransitionPro ; got 6 points: go to 'GANO'
        ret
        
storeFirstDigitPro:
        mov R8, R9                 ; save in R9 the first digit's value (R8)
        inc R4                     ; inc segment index to move to next segment
        clr R8                     ; reset index for the number (starts at 0)
        ret
        
; Update Pro Mode scores 
; TODO: Document
SUB_updateProScore:
        cmp.b &0x440C, R11       ; Check for new High Score
        jge newRecordPro       ; Jump if R11 >= previous High Score
        jmp endProScoreUpdate
        
newRecordPro:
        mov.b R11, &0x440C     ; 0updates FRAM PRO Score to value of R11
        mov.b R12, &0x4406     ; updates FRAM PRO Name to value of R12
        jmp endProScoreUpdate

endProScoreUpdate:
        ret
        
; ===== Update Digit subroutines =====
; ===== 
; Objective: Updates the display based on the timer, current segment, and 
;            index digit for test mode. 
; =====
; ===== 
; Preconditions: R5 has to be less or equal to 9 (nine).  
; =====
; ===== 
; Postconditions: Updates the next digit in the corresponding segment.
; =====
; ===== Author: Luis D. Gonzalez, Anthony Mendez =====
; ===== Date: 11/22/22 - 11/25/22 =====
        
SUB_updateProDigit:
        cmp #9, R8 ; if the index goes beyond 9, the player loses
        jeq SUB_perdioTransitionPro
        inc R8
        jmp updateProSegment
        
updateProSegment:
        call #SUB_proModeScreen
        ret
        
; ===== 'PERDIO' Screen Subroutines =====
; ===== 
; Objective: Displaying 'PERDIO' for 5 seconds 
; =====
; =====
; Preconditions: As soon as a digit from the second onwards is not equal to 
;                the first digit selected. Also if any digit goes beyond 9
; =====
; =====
; Postconditions: Move to 'S2CLR' screen after 5 seconds
; =====
; ===== Author: Anthony Mendez =====
; ===== Date: 11/22/22 - 11/25/22 =====
SUB_perdioScreen:
        mov  #PERDIO, R15
        call #SUB_displayCharacterArray
        ret

; ===== 'GANO' Screen Subroutines =====
; ===== 
; Objective: Displaying 'GANO' for 5 seconds 
; =====
; =====
; Preconditions: If all six digits are equal, player wins and gets this screen
; =====
; =====
; Postconditions: Move to 'S2CLR' screen after 5 seconds
; =====
; ===== Author: Anthony Mendez =====
; ===== Date: 11/22/22 - 11/25/22 =====
SUB_ganoScreen:
       mov  #GANO, R15
       call #SUB_displayCharacterArray
       ret

; ===== S2CLR Screen Subroutines =====
; ===== 
; Objective: Displaying 'S2CLR'. If S1.1 is pressed, return to title screen.
;            If S1.2 is pressed, TEST and PRO records turn to zero
; =====
; =====
; Preconditions: This screen must be drawn 5 seconds after "PERDIO" or "GANO"
; =====
; =====
; Postconditions: If s1.2 is pressed, 0x440C (Top PRO Score), 
;                 and 0x440D (Top TEST Score) turn to zero. 
;                 If S1.2 is pressed, return to title screen
; =====
; ===== Author: Anthony Mendez =====
; ===== Date: 11/22/22 - 11/25/22 =====
SUB_S2CLRscreen:
       mov  #S2CLR, R15
       call #SUB_displayCharacterArray
       ret
       
SUB_clrRecords:
       mov   #NO_NAME, &0x4406 ; resets high scorer
       mov.b #0, &0x440C   ;sets top PRO Score to zero
       mov.b #0, &0x440D   ;sets top TEST Score to zero
       ret

; ===== General subroutines. =====

; ===== General LCD display subroutines. =====
; ===== 
; Objective: Given an array of numbers, displays the characters at those 
;            positions on the LCD. 
; =====
; ===== 
; Preconditions: R15 must be an array of size 6 containing only numerical values, 
;                in order to access the values at that index and write it
;                to the LCD's memory. Screen should also be cleared beforehand.
;                Each integer, representing the character to be drawn, should
;                go from 0-36.
; =====
; ===== 
; Postconditions: Draws the indicated numbers or letters onto the LCD.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/14/22-11/17/22 =====
SUB_displayCharacterArray: ; sets up registers to be utilized by the subroutines
        push.w R5 ; Lookup index for the character arrays
        push.w R6 ; Iteration index for LCD memory offsets/6 array elements
        push.w R7 ; Value for current LCD memory offset (same index as R6)
        ; initialize values
        mov #0, R6
        jmp displayCharacterData

displayCharacterData:
        ; Perform this check first (edge case: Empty char in last index of arr)
        cmp #6, R6 ; end of the array 
        jeq endDrawing
        ; Proceed with drawing all other characters
        mov.b @R15, R5 ; Store value of the index for the current letter to draw
        mov.b LCD_OFFSETS(R6), R7 ; where in LCD memory to draw (offset)
        ; increment first to safely skip writing to the screen when EMPTY
        inc R6
        inc R15 ; increase to next location in array
        ; don't move 0x00 (EMPTY) into memory to prevent overwrites
        cmp #36, R5 
        jeq displayCharacterData 
        ; draw characters
        mov.b CHAR_H(R5), 0x0A20(R7)
        mov.b CHAR_L(R5), 0x0A20+1(R7)
        jmp displayCharacterData

endDrawing:  ; restore non-permanent modification registers (check comments)
        pop R7
        pop R6
        pop R5
        ret  

; ===== Segment display subroutines. =====
; ===== 
; Objective: Given the index, displays the characters at the corresponding  
;            (TEST or PRO) mode segment on the LCD. 
; =====
; ===== 
; Preconditions: Each integer, representing the character to be drawn, should
;                go from 0-9, that number is stored in R8. R4 should store the
;                number of the segment to be drawn on.
; =====
; ===== 
; Postconditions: Draws the indicated numbers onto the segment.
; =====
; ===== Author: Anthony Mendez =====
; ===== Date: 11/26/2022 =====
SUB_displaySegmentData:
        push.w R7 ; Value for current LCD memory offset (same index as R4)
        mov.b LCD_OFFSETS(R4), R7 ; where in LCD memory to draw (offset)
        ; increment first to safely skip writing to the screen when EMPTY
        mov.b DIGIT_H(R8), 0x0A20(R7)
        mov.b DIGIT_L(R8), 0x0A20+1(R7)
        pop R7 ; restore non-permanent modification registers (check comments)
        ret

; ===== Timer management subroutines =====
; ===== 
; Objective: Control the timer ISR per the program's needs.
; =====
; ===== 
; Postconditions: Enables, disables, or resets the current timer.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/18/22 =====
SUB_disableTimer: ; Disabling a timer prevents registers from incrementing
                  ; infinitely and potentially overflowing. 
        clr R13   ; Clear current cycle count and desired cycle count
        clr R14
        bic #CCIE, &TA0CCTL0 ; Disable the timer
        ret
        
SUB_enableTimer: 
        bis #CCIE, &TA0CCTL0 ; Enable the timer. R13/R14 will have been cleared
                             ; from before. This is always called after 
                             ; disabling the timer.
        ret

; ===== Delay subroutines. =====
; ===== Objective: Decrements from a large value to stall for time. =====
; ===== Preconditions: Must be called after an interrupt or button press. =====
; ===== Posconditions: Stalls the program for a bit while inputs are processed.=====
; ======== Author: Yariel Mercado ========
; ======== Date: 11/21/22 ========
SUB_delay:
        push.w R10 ; store original value
        mov #0xFFFF, R10  
        jmp loop
        
loop:
        dec R10
        jnz loop
        pop R10 
        ret ; returns to whatever subroutine the delay was called from

; ===== Interupt subroutines. =====

; ===== Timer Interrupt Subroutine =====
; ===== 
; Objective: Control the program's time sensitive events.
; =====
; ===== 
; Preconditions: Can only handle time dependent states or transitions. The timer
;                interrupt is called every 1/8 of a second. This allows us to
;                control more specific units of time.  
; =====
; ===== 
; Postconditions: Switches to a different state or executes a program action
;                 based on the current time elapsed. 
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/18/22 =====
ISR_TIMER:
        inc R14 ; keeps track of the timer's ticks
        cmp R13, R14  ; is the current number of cycles == desired #cycles
        jne TIMER_ISR_END ; not equal. End and continue to increase time

        ; Desired number of seconds have elapsed
        call #SUB_timerStateManager
        clr R14 ; reset the count
        jmp TIMER_ISR_END

TIMER_ISR_END:
        reti
        
; ===== Button Interrupt Subroutines. =====
; ===== 
; Objective: Attend user presses on S1/2 appropriately via interrupts.
; =====
; ===== 
; Preconditions: Cannot handle time sensitive events, only those triggered by
;                button presses. 
; =====
; ===== 
; Postconditions: Switches to a different state or executes a program action
;                 based on the current state.
; =====
; ===== Author: Yariel Mercado =====
; ===== Date: 11/15/22-11/21/22 =====
ISR_PORT1:      
        ; Check S1
        bit.b   #00000010B, &P1IFG ; Test P1IFG to detect interrupt from S1    
        jnz     S1Success          ; 0 == interrupt not pending
        ; Check S2
        bit.b   #00000100B, &P1IFG
        jnz     S2Success
        ; Didn't recieve S1/2 interrupts
        bic.b #00000110B, &P1IFG      ; Clear interrupt flags
        jmp     PORT1_ISR_END  
        
S1Success: ; S1 or S2 have been succesfully pressed
        call  #SUB_delay              ; Helps process one press at a time
        bic.b #00000110B, &P1IFG      ; Clear interrupt flags
        call  #SUB_S1ButtonHandler
        jmp PORT1_ISR_END
        
S2Success:
        call  #SUB_delay              ; Helps process input one press at a time
        bic.b #00000110B, &P1IFG      ; Clear interrupt flags
        call  #SUB_S2ButtonHandler
        jmp PORT1_ISR_END

PORT1_ISR_END:
        call #SUB_buttonStateManager  ; Manage program state
        reti
        END
        
